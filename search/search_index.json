{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started with parrot","text":"<p>parrot is designed to process continuously recorded THz traces from a THz-TDS. parrot can process the raw, continuous measurement data (consisting of time, position of the delay stage, and the THz signal) and retrieves an averaged, high quality THz trace with access to interpolated individual traces as well as further statistics.</p> <p>See the jupyter notebook <code>example.ipynb</code>, <code>example_compact.ipynb</code>, and python file <code>example.py</code> in the root directory, which show step-by-step how parrot can be used.</p> <p>To achieve this goal, parrot is divided into three main modules:</p> <ol> <li> <p>Load</p> </li> <li> <p>Process</p> </li> <li> <p>Plot</p> </li> </ol> <p>You can also find the corresponding documentation for each module also in the header above.</p> <p>The program is written by Tim Vogel at the Photonics and Ultrafast Laser Science (PULS) group at the Ruhr-University Bochum, Germany and released as Free and Open Source Software (FOSS).</p>"},{"location":"#virtual-environment-for-forkingdebugging-of-parrot","title":"Virtual environment for forking/debugging of parrot","text":"<p>The following steps are meant for development purposes of parrot and should not be necessary to run parrot.</p> <p>The Anaconda environment is stored in <code>enivronment.yml</code>, which is automatically created by running <code>conda env export --from-history &gt; environment.yml</code>. Unfortunately, there is currently a bug in Python's virtual-environment <code>venv</code> which, due to a cmake error, fails to install the classic `requirement.txt\u00b4 and thus the use of an Anaconda environment. To manually fork the code and create a corresponding virtual environment, simply run the following commands in the root directory of the downloaded source files:</p> <pre><code>conda create --name parrot --file .\\environment.yml\nconda activate parrot\npython .\\Example_compact.py\n</code></pre>"},{"location":"load/","title":"Load","text":"<p>This page discusses aspects of parrot's <code>Load</code> class.</p> <p>You can also search for specific functions in this class (or other classes) using the search box on the top right.</p>"},{"location":"load/#objective-of-the-class","title":"Objective of the class","text":"<p>It is important to note, that this class is not necessary to use parrot successfully.</p> <p>The goal is always to extract the stored raw data and bring it into the common format used throughout parrot:</p> <p>A Python dictionary containing time, delay, and signal.</p> <p>It works more like a shortcut/convenience class for established recording devices and file types we typically use in our lab</p> <p>Currently implemented in the file <code>recording_device.py</code> are:</p> <ol> <li> <p>Lock-In amplifier (Zurich Instruments, saved as <code>.h5</code>)</p> </li> <li> <p>Oscilloscope (Rohde &amp; Schwarz, saved as <code>.csv</code>)</p> </li> <li> <p>Digital oscilloscope (PicoScope, saved as <code>.mat</code>)</p> </li> <li> <p>DAQ (Dewesoft, saved as <code>.h5</code>)</p> </li> </ol> <p>Special functions are implemented for the lock-in amplifier (LIA), Ideally, two signals are recorded from the LIA: <code>X</code> and <code>Y</code>. parrot can optimize the phase angle after recording to maximize the <code>X</code> component and minimize the <code>Y</code> component, which is then discarded.</p> <p>parrot can also optimize the phase when the LIA was not the direct data acquisition (DAQ) device, but was only connected in-between, e.g. the two-channel signal was recorded with the Dewesoft Sirius Mini DAQ.</p>"},{"location":"plot/","title":"Plot","text":"<p>This page discusses aspects of the <code>plot</code>-module of parrot.</p> <p>After processing the data with the <code>process</code> module, a single Python dictionary called <code>data</code> is returned. This dictionary contains general metadata about the dataset, such as the number of traces, but also the data itself, specifically each sliced &amp; averaged individual trace, as well as averaged traces in the time and frequency domains.</p> <p>The <code>plot</code> module currently supports two different functions that can work with <code>data</code>.</p> <pre><code># Simple Plot giving an overview of the data\nparrot.plot.simple_multi_cycle(data)\nplt.savefig(\"Simple_plot.png\", dpi=600)\n# Extended plot, showing increase in dynamic range and standard deviation in time domain\nparrot.plot.extended_multi_cycle(data)\nplt.savefig(\"Extended_plot.png\", dpi=600)\n</code></pre> <p>Both are discussed in detail in the following sections:</p>"},{"location":"plot/#simple-multi-cycle","title":"Simple multi cycle","text":"<pre><code>def simple_multi_cycle(data,\n                       min_THz_frequency=0e12,\n                       max_THz_frequency=10e12,\n                       threshold_dB=10,\n                       figsize=None,\n                       water_absorption_lines=True,\n                       debug=False):\n</code></pre> <p>Creates three subplots showing the averaged THz trace in both the time and frequency domains along with the measured dark traces. For the frequency domain, two perspectives are given, one on a normalized linear scale and one on a logarithmic scale. Additional information is given in the title of the figure as well as in the plots, consisting of the signal-to-noise ratio (SNR) in the time domain, the dynamic range in the frequency domain as well as two different bandwidths, full-width at half-maximum (FWHM) and a bandwidth on a logarithmic scale depending on <code>threshold_dB</code>. The input parameters of <code>simple_multi_cycle()</code> are discussed below.</p>"},{"location":"plot/#min_thz_frequency-max_thz_frequency","title":"<code>min_THz_frequency</code>, <code>max_THz_frequency</code>","text":"<p>Input: <code>float</code>. When reading the data, the sampling rate is checked and, if <code>filter_signal=True</code> in <code>process.run()</code>, the maximum displayable internal THz frequency is typically limited to 50 THz, which should be sufficient for most THz experiments. (It can, of course, be adjusted in the <code>process</code> module if an even higher THz frequency is required).</p> <p>However, this large frequency is not very suitable for display purposes. For this reason, the min. and max. THz frequency are further restricted for plotting the data. The default settings of <code>simple_multi_cycle()</code> set these to 0 THz and 10 THz.</p>"},{"location":"plot/#threshold_db","title":"<code>threshold_dB</code>","text":"<p>Input: <code>float</code>.  tries to give an estimate of the received THz pulse by analyzing the full width at half maximum (FWHM) and the bandwidth of the spectrum on a logarithmic scale. Since there is no official definition for a logarithmic bandwidth and the definition of the signal hitting the noise floor can often be arbitrary in time (due to the fluctuations of the noise floor itself), a threshold of 10 dB is set as a standard parameter. This means that the largest frequency bandwidth of the THz signal that is at least 10 dB above the noise floor is selected. Any dip in the signal or peak in the noise floor at a given frequency will interrupt the bandwidth. Only the largest continuous portion of the THz signal above the specified threshold is selected.</p> <p>While the linear FWHM bandwidth is suitable for nonlinear THz spectroscopy (because the frequencies covered by this bandwidth should have the relatively highest amplitude to induce nonlinear effects), the logarithmic bandwidth with a 10 dB threshold is suitable for linear THz spectroscopy. Programs such as phoeniks offer to extract the refractive index and absorption coefficient from (averaged) THz time-domain data of a reference and sample measurement. The algorithms are typically stable enough to extract the relative information when the signal is 10 dB above the noise floor.</p>"},{"location":"plot/#figsize","title":"<code>figsize</code>","text":"<p>Input: <code>None</code> or <code>(float, float)</code>. This parameter is used as a shortcut to get suitable plots in the right size directly. For example, if you are characterizing your THz source and/or detection scheme and want to tell others about it at the next meeting, you can specify a <code>figsize</code> here that will scale the plot to the dimensions you need, e.g. for a presentation. You have to give the width and height as a tuple and the unit is unfortunately in inches. However, you can get the appropriate dimension in [cm] by dividing the input by 2.54.</p> <p>For example:</p> <pre><code>simple_multi_cycle(data, figsize=(30 / 2.54, 18 / 2.54))\nplt.savefig(\"Plot.png\", dpi=600)  # Saves the plot in the current working directory\n</code></pre>"},{"location":"plot/#water_absorption_lines","title":"<code>water_absorption_lines</code>","text":"<p>Input: <code>bool</code>. For convenience, the water absorption lines at THz frequencies can be enabled or disabled and are extracted from the HITRAN online database using HAPI.</p> <p>Reference</p> <p>R.V. Kochanov, I.E. Gordon, L.S. Rothman, P. Wcislo, C. Hill, J.S. Wilzewski,</p> <p>HITRAN Application Programming Interface (HAPI): A comprehensive approach to working with spectroscopic data,</p> <p>J. Quant. Spectrosc. Radiat. Transfer 177, 15-30 (2016)</p> <p>https://hitran.org/hapi/</p>"},{"location":"plot/#debug","title":"<code>debug</code>","text":"<p>Input: <code>bool</code>. For debugging purposes.</p>"},{"location":"plot/#extended-multi-cycle","title":"Extended multi cycle","text":"<pre><code>def extended_multi_cycle(data,\n                         min_THz_frequency=0e12,\n                         max_THz_frequency=10e12,\n                         threshold_dB=10,\n                         figsize=None,\n                         snr_timedomain=False,\n                         water_absorption_lines=True):\n</code></pre> <p>Creates three subplots that provide more information, particularly regarding the averaging effect of using an ensemble of individual traces. The plot consists of the time domain trace as before, a frequency domain trace, and a plot that shows the dynamic range for a cumulative average of the light trace versus the averaged dark trace. Ideally, this double-log plot should show a line. Due to nonstationary noise or other drifts in the setup, the dynamic range can become saturated or even degraded as more individual traces are averaged.</p>"},{"location":"plot/#snr_timedomain","title":"<code>snr_timedomain</code>","text":"<p>Input: <code>bool</code>. Enables/disables whether to calculate and display the signal-to-noise ratio (SNR) in time domain.</p>"},{"location":"plot/#min_thz_frequency-max_thz_frequency-threshold_db-figsize-water_absorption_lines","title":"<code>min_THz_frequency</code>, <code>max_THz_frequency</code>, <code>threshold_dB</code>, <code>figsize</code>, <code>water_absorption_lines</code>","text":"<p>See description at Simple multi cycle.</p>"},{"location":"process/","title":"Process","text":"<p>This page discusses aspects concerning the <code>process</code> module of parrot.</p>"},{"location":"process/#objective-of-the-module","title":"Objective of the module","text":"<p>Continuously recorded raw data containing several cycles of a sinusoidal delay line with the corresponding THz traces are processed. In particular, the possible delay difference between position and THz signal is compensated. This is possible because the signal itself is used as a self-reference in the forward/backward motion of the delay state, which ideally should overlap. By correcting this phase delay between the two channels, as well as possible bandpass filtering, we can obtain a high-quality averaged THz trace. In addition, statistics can be computed from the large number of traces, which is particularly useful for determining the dynamic range (DR) and signal-to-noise ratio (SNR) of the traces.</p>"},{"location":"process/#prepare-data","title":"Prepare data","text":"<p>As with the other classes, a logger is started which collects messages at various places in the program. There are multiple log-levels and the standard is the log-level <code>WARNING</code>, to not flood the print-out with too many messages when analyzing multiple files. By setting <code>parrot.config.set_debug(True)</code>, the log-level is reduced to <code>INFO</code> and, as the name implies, more information are given what the program is doing, which is in particular helpful when analyzing a single file.</p> <p>Prepare data splits the process in multiple steps, which are discussed in the following:</p>"},{"location":"process/#1-filter_position","title":"1. <code>filter_position</code>","text":"<p>Most DAQs have the same sampling rate for the position signal as for the THz signal (and this is recommended anyway for synchronicity reasons). However, while the THz signal requires a reasonably high sampling rate (depending on e.g. the time window in the light time, the bandwidth of the THz pulse), commercial voice-coil shakers typically have a sinusoidal motion profile and frequencies in the order of tens of Hz. This results in massive oversampling of the position signal, adding high frequency noise. This is especially bad because this signal is later used for the x-axis, resulting in fluctuating x-values and possible degradation of the THz signal when averaging multiple traces. The solution is to apply a low pass filter to the position data. The user is free to apply either a low pass or high pass filter to the data. In general, it is recommended to apply only a low pass filter with a -3dB frequency of 5x the oscillation frequency. For a 20 Hz oscillating delay line, an appropriate low pass filter would be 100 Hz. This ensures that subtle distortions that correspond to real position deviations are captured, without having high frequency noise that is not physically caused by the movement of the stage.</p> <p>Internally, the low-/high-/bandpass filter <code>sosfiltfilt</code> from scipy.signal are used. This filter is a forward-backward digital filter, meaning it is applied once in forward direction and once backward direction. This results in a net-zero phase effect from the filter, which is important to not increase the phase delay between position and THz signal even more. <code>sos</code> of <code>sosfiltfilt</code> stands for cascaded second-order sections, since they have fewer numerical problems.</p>"},{"location":"process/#2-filter_signal","title":"2. <code>filter_signal</code>","text":"<p>It may be useful to apply a filter to the THz signal as well. The same <code>sosfiltfilt</code> function is used.</p> <p>However, it makes sense to apply different filter settings. If you want to apply a filter to the Thz data at all, a high pass filter in the order of the shake frequency is usually a good choice. Slight misalignment of the probe beam or other sources of noise such as vibration can affect the baseline of the THz data. In particular, the frequency of the shaker can have a relatively small amplitude effect on the THz trace. A high-pass filter can remove any offset or low-frequency fluctuations, making it easier to superimpose and effectively average the THz trace. A similar approach, which may be even better for baseline correction, is to record a \"dark\" trace, i.e. all settings of the experiment are the same, only the THz beam is blocked. This data file should have the same baseline as the THz signal. Later, these two traces can be subtracted from each other.</p>"},{"location":"process/#3-resample_data","title":"3. <code>resample_data</code>","text":"<p>f the DAQ's sampling rate was too high for the signal bandwidth, we will introduce unnecessary high-frequency noise even though we have no signal bandwidth at those frequencies (at lab frequencies). We can resample the data to reduce the data rate. This will also speed up the processing of the measurement data because downsampling reduces memory requirements.</p> <p>However, resampling the data is a bit tricky because we have the sampling time in lab time but not in light time [ps]. <code>self.max_THz_frequency</code> is defined in the time frame of the THz sample. The maximum slope of the position data vs. lab time is the smallest max. THz frequency.</p> <pre><code>max_native_frequency = 1 / (np.max(np.gradient(data[\"position\"], dt)) * data[\"scale\"] * dt)\n</code></pre> <p>where <code>self.dt</code> is the time step of the raw data (inverse of the sampling rate), <code>self.data[\"scale\"]</code> is the scale to convert from the position value in [V] to the light time is [s].</p> <p>TODO: Before downsampling, it would be better to low-pass filter the data. This would not only improve the processing speed due to a smaller memory size, but also increase the fidelity of all THz traces due to the removal of high frequency noise. However, it depends on the THz system in use whether the ADC is really the limiting noise factor of the system.</p>"},{"location":"process/#4-get_multiple_index","title":"4. <code>get_multiple_index</code>","text":"<p>To divide a continuous recording into subsections, each containing only a single THz trace, the extrema of the sinusoidal delay must be detected. The function performs a Fast Fourier Transformation (FFT) and analyzes the peak in the frequency domain that is not the DC peak. The inverse of this frequency is then used as the minimum distance to reliably find all peaks using <code>find_peaks</code> from scipy.signal.</p>"},{"location":"process/#5-cut_incomplete_traces","title":"5. <code>cut_incomplete_traces</code>","text":"<p>The oscillating delay line is typically not synchronized with the data acquisition. have a random position and are not useful for the THz averaging process. To ensure that only complete traces are processed later, the first and last trace are removed from the data set.</p>"}]}